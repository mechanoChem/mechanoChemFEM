<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mechanoChemFEM: Example 1 : Brain morph with finte strain mechanics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mechanoChemFEM
   &#160;<span id="projectnumber">0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Example 1 : Brain morph with finte strain mechanics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>We solve two diffusion reaction equations: </p><p class="formulaDsp">
\[ \frac{\partial C_\text{1}}{\partial t}+\nabla\cdot\boldsymbol{j}_1=r_1 \\ \frac{\partial C_\text{2}}{\partial t}+\nabla\cdot\boldsymbol{j}_2=r_2 \]
</p>
<p> where \(\boldsymbol{j}_1 \) and \(\boldsymbol{j}_2 \) are flux terms: </p><p class="formulaDsp">
\[ \boldsymbol{j}_1^{diff}=-M_1\nabla C_\text{1}; \quad \boldsymbol{j}_2^{diff}=-M_2\nabla C_\text{2}\\ \]
</p>
<p> \(r_1\) and \(r_2\) are reaction terms, in this example they are </p><p class="formulaDsp">
\[ r_1= reac_{10}; \quad r_1= reac_{20} \]
</p>
<p>Besides chemistry, we also solve elasticity problem at finite strain: </p><p class="formulaDsp">
\[ \nabla\cdot\boldsymbol{T} = \boldsymbol{0}\\ \boldsymbol{T}= \frac{1}{\det{\boldsymbol{F}^{\text{e}}}}\frac{\partial W}{\partial \boldsymbol{F}^{\text{e}}}\boldsymbol{F}^{\text{e}} \]
</p>
<p> To make it more interesting, we have mechanical deformation due to species intecalation. </p><p class="formulaDsp">
\[ \boldsymbol{F}=\boldsymbol{F}^{\text{e}}\boldsymbol{F}^{\text{g}}\\ \boldsymbol{F}^{\text{g}}=\left(\frac{C_\text{1}}{C_\text{10}}\right)^{\frac{1}{3}}\mathbb{1} \]
</p>
<p> For deomstraion we use a very simple mesh with three different domains. We will solve the abolve equations on domain 1 and 2.  <style>div.image img[src="domain.png"]{width:500px;}</style>  </p><div class="image">
<img src="domain.png" alt="domain.png"/>
</div>
<h2><a class="anchor" id="define1"></a>
Define primary variables over different domains</h2>
<p>In deal.ii to solve equations in different domains, <code>Fe_Nothing</code> is used and different <code>Fe_System</code> need to be defined. By using dealMutiphysics, it can be easily taken care of by two user defined vector: <code><b>primary_variables</b></code> and <code><b>FE_support</b></code>. </p><div class="fragment"><div class="line">std::vector&lt;std::vector&lt;std::string&gt; &gt; primary_variables(3);        </div><div class="line">primary_variables[0].push_back(<span class="stringliteral">&quot;u&quot;</span>); primary_variables[0].push_back(<span class="stringliteral">&quot;component_is_vector&quot;</span>);</div><div class="line">primary_variables[1].push_back(<span class="stringliteral">&quot;c1&quot;</span>); primary_variables[1].push_back(<span class="stringliteral">&quot;component_is_scalar&quot;</span>);</div><div class="line">primary_variables[2].push_back(<span class="stringliteral">&quot;c2&quot;</span>); primary_variables[2].push_back(<span class="stringliteral">&quot;component_is_scalar&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> number_domain=3;</div><div class="line"><span class="keywordtype">int</span> mech_degree=1;</div><div class="line"><span class="keywordtype">int</span> diff_degree=1;</div><div class="line">std::vector&lt;std::vector&lt;int&gt; &gt; FE_support(number_domain);<span class="comment">// store order of polynomial basis functions, 0 means FE_Nothing   </span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;2;i++){</div><div class="line">    FE_support[i].push_back(mech_degree);</div><div class="line">    FE_support[i].push_back(diff_degree);</div><div class="line">    FE_support[i].push_back(diff_degree);</div><div class="line">}</div><div class="line">FE_support[2].push_back(0);</div><div class="line">FE_support[2].push_back(0);</div><div class="line">FE_support[2].push_back(0);</div></div><!-- fragment --><p> Then user can use function </p><div class="fragment"><div class="line"><a class="code" href="classhp_f_e_m.html#afe86b756fb757221f5a8a16c956b7e76">hpFEM&lt;dim&gt;::setup_FeSystem</a>(fe_system, fe_collection, q_collection, primary_variables_dof,primary_variables,FE_support,volume_quadrature);</div></div><!-- fragment --><p> to setup <code>fe_system</code>, <code>fe_collection</code>, <code>q_collection</code> with quadarture points : <code>volume_quadrature</code>.<br />
 If the mesh is generated outside deal.ii (e.g. cubit), material ID can be pre-defined. To setup the <code>Fe_System</code> for each element, we can simily use </p><div class="fragment"><div class="line"><a class="code" href="classhp_f_e_m.html#a12205240784051ad249a536cb7ee98d5">hpFEM&lt;dim&gt;::set_active_fe_indices</a> (FE_support, <a class="code" href="classhp_f_e_m.html">hpFEM&lt;dim&gt;::dof_handler</a>);</div></div><!-- fragment --> <h2><a class="anchor" id="outPut"></a>
Output and restart</h2>
<p>We can use class <code>FEMdata</code> to easily write output and have capability of re-start the code. After initializing the class we can set the output name by </p><div class="fragment"><div class="line"><a class="code" href="class_f_e_mdata.html#a770f8539c16d21624bcedc1f6bee9d68">FEMdata&lt;dim,vectorType&gt;::set_output_name</a>(primary_variables);</div></div><!-- fragment --><p> And write vtk file using </p><div class="fragment"><div class="line">std::string output_path = output_directory+<span class="stringliteral">&quot;output-0.vtk&quot;</span>;</div><div class="line"><a class="code" href="class_f_e_mdata.html#a62d54e01135c4ab0b58f51441732dca3">FEMdata&lt;dim,vectorType&gt;::write_vtk</a>(solution_0, output_path);</div></div><!-- fragment --><p> To use restart we first need to create a snapshot and resume the vector from ths snapshot </p><div class="fragment"><div class="line">std::string snapshot_path = snapshot_directory+<span class="stringliteral">&quot;snapshot-&quot;</span>+std::to_string(current_increment)+<span class="stringliteral">&quot;.txt&quot;</span>;</div><div class="line"><a class="code" href="class_f_e_mdata.html#aaffa90fc1adcd37311428f7e49b98263">FEMdata&lt;dim,vectorType&gt;::create_vector_snapshot</a>(solution_old, snapshot_path);</div><div class="line"><a class="code" href="class_f_e_mdata.html#a2611613e158345b619062316e281c4c9">FEMdata&lt;dim,vectorType&gt;::resume_vector_from_snapshot</a>(solution_new, snapshot_path);</div></div><!-- fragment --> <h2><a class="anchor" id="assemble"></a>
Assemble rsesidual functions of two diffuction reactions equations and elasticity at finite strain</h2>
<p>In FEM modeling, we need to provide system_matrix (Jacobin matrix) \(\frac{\partial \boldsymbol{R}}{\partial \boldsymbol{x}} \), and right hand side vector \(-\boldsymbol{R}\). They are usually achieved by assemble <code>local_matrix</code> and <code>local_rhs</code> over elements. We first need to overload abstract function <code>updateLinearSystem</code>. In this exmaple we need to solve two diffusion-reaction equations and one finite strain mechanics problem. </p>
<h3><a class="anchor" id="DRq"></a>
diffusion-reaction equations</h3>
<p>For diffusion-reaction problems we need to provide the flux and reaction term, and in this example we also have advection and few extra terms for stablization. All the term will be combined into <code>flux</code> and <code>reaction</code> terms. </p><p class="formulaDsp">
\[ \boldsymbol{j}_1^{diff}=-M_1\nabla C_\text{1}; \quad \boldsymbol{j}_2^{diff}=-M_2\nabla C_\text{2}\\ \]
</p>
<p> The following code basically evaluates the terms shown above. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points;q++){</div><div class="line">    reac_11[q]=0; reac_12[q]=0; c_1_reac[q]=0; </div><div class="line">    reac_21[q]=0; reac_22[q]=0; c_2_reac[q]=0; </div><div class="line">    velDotGradSpatc_1[q]=0;</div><div class="line">    velDotGradSpatc_2[q]=0;</div><div class="line">    <span class="keyword">const</span> Point&lt;dim&gt; posR = fe_values.quadrature_point(q);</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim;i++){</div><div class="line">        c_1_flux[q][i]=-mobility_c1*c_1_grad[q][i];</div><div class="line">        c_2_flux[q][i]=-mobility_c2*c_2_grad[q][i];</div><div class="line">    }       </div><div class="line">    c_1_reaction[q]=reac_10;</div><div class="line">    c_2_reaction[q]=reac_20;</div><div class="line">}</div></div><!-- fragment --><p> Also in above code we need values for primary variables and their gradients (at current configuration), we can evaluate them using <code>evaluation</code> <code>functions:</code> </p><div class="fragment"><div class="line"><a class="code" href="group___evaluation_functions.html#ga399ae2353249293211c021848a64175c">evaluateScalarFunction</a>(fe_values, primary_variables_dof[1], ULocalConv, c_1_conv);</div><div class="line"><a class="code" href="group___evaluation_functions.html#ga399ae2353249293211c021848a64175c">evaluateScalarFunction</a>(fe_values, primary_variables_dof[1], U0Local, c_1_0);</div><div class="line"><a class="code" href="group___evaluation_functions.html#ga399ae2353249293211c021848a64175c">evaluateScalarFunction</a>(fe_values, primary_variables_dof[1], ULocal, c_1);   </div><div class="line"><a class="code" href="group___evaluation_functions.html#ga3ee6127c2c5c8333bb7fb384dcdb431f">evaluateScalarFunctionGradient</a>(fe_values, primary_variables_dof[1], ULocal, c_1_grad,defMap);</div><div class="line"></div><div class="line"><a class="code" href="group___evaluation_functions.html#ga399ae2353249293211c021848a64175c">evaluateScalarFunction</a>(fe_values, primary_variables_dof[2], ULocalConv, c_2_conv);</div><div class="line"><a class="code" href="group___evaluation_functions.html#ga399ae2353249293211c021848a64175c">evaluateScalarFunction</a>(fe_values, primary_variables_dof[2], U0Local, c_2_0);</div><div class="line"><a class="code" href="group___evaluation_functions.html#ga399ae2353249293211c021848a64175c">evaluateScalarFunction</a>(fe_values, primary_variables_dof[2], ULocal, c_2);   </div><div class="line"><a class="code" href="group___evaluation_functions.html#ga3ee6127c2c5c8333bb7fb384dcdb431f">evaluateScalarFunctionGradient</a>(fe_values, primary_variables_dof[2], ULocal, c_2_grad,defMap);</div></div><!-- fragment --><p> The weak form of diffution-reaction equations can be written as </p><p class="formulaDsp">
\[ \mathscr{R}=\int_{\Omega_{\text{e}}}w\frac{\partial C}{\partial t}\text{d}v-\int_{\Omega_{\text{e}}} \nabla w \boldsymbol{j} \text{d}v+\int_{s}w\boldsymbol{j}\cdot\boldsymbol{n} \text{d}s=\int_{\Omega_{\text{e}}}w r \text{d}v \]
</p>
<p> After we have all fluxes and reaction terms we can simply call the corresponding residual function to evaluate the residual for \(C_\text{1}\) and \(C_\text{2}\) . </p><div class="fragment"><div class="line"><a class="code" href="class_residual.html#a144663fb81fc60d4db0c5a8e45176e61">Residual&lt;vectorType,dim&gt;::residualForDiff_ReacEq</a>(fe_values, primary_variables_dof[1], R, defMap, c_1, c_1_conv, c_1_flux, c_1_reaction);</div><div class="line"><a class="code" href="class_residual.html#a144663fb81fc60d4db0c5a8e45176e61">Residual&lt;vectorType,dim&gt;::residualForDiff_ReacEq</a>(fe_values, primary_variables_dof[2], R, defMap, c_2, c_2_conv, c_2_flux, c_2_reaction);</div></div><!-- fragment --><p> Please note the above functions will not do the the boundary integration (in this example we have trivial neumman boundary condition). To apply neumman boundary conditions please check <code>Residual</code> class which offer a easy way to apply a variety of tpye of neumman boundary conditions. </p>
<h3><a class="anchor" id="mechanics"></a>
Finite strain mechanics using NeoHookean model</h3>
<p>For all mechanics problem we first need to define stress, strain and have a deformation map from which we obtain the strain </p><div class="fragment"><div class="line">dealii::Table&lt;3, Sacado::Fad::DFad&lt;double&gt; &gt; P(n_q_points,dim,dim);</div><div class="line">dealii::Table&lt;3, Sacado::Fad::DFad&lt;double&gt; &gt; Fe(n_q_points,dim,dim);</div><div class="line"><a class="code" href="structdeformation_map.html">deformationMap&lt;Sacado::Fad::DFad&lt;double&gt;</a>, dim&gt; defMap(n_q_points); </div><div class="line"><a class="code" href="group___evaluation_functions.html#ga62b026b5bcee0bda21159ff6782b4b59">getDeformationMap</a>(fe_values, primary_variables_dof[0], ULocal, defMap);</div></div><!-- fragment --><p> In this example, we consider no growth and isotropic growth: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points;q++){</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i){</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j){</div><div class="line">            Fe[q][i][j]=0.0;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (c_1_0[q] &gt; 0){</div><div class="line">        <span class="keywordflow">if</span>(std::strcmp(GROWTH.c_str(),<span class="stringliteral">&quot;Uniform&quot;</span>)==0 ){</div><div class="line">            fac[q] = 1.0; <span class="comment">//Uniform growth</span></div><div class="line">        } </div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(std::strcmp(GROWTH.c_str(),<span class="stringliteral">&quot;Isotropic&quot;</span>)==0 ){</div><div class="line">            fac[q]=std::pow((c_1[q]/c_1_0[q]), 1.0/3.0); <span class="comment">// Isotropic Growth</span></div><div class="line">        } </div><div class="line">        <span class="keywordflow">else</span>{pcout &lt;&lt; <span class="stringliteral">&quot;Growth type not supported\n&quot;</span>; exit(1);}</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {fac[q] = 1.0;}</div><div class="line">    </div><div class="line"><span class="keywordflow">if</span> (fac[q] &lt;= 1.0e-15){</div><div class="line">        printf(<span class="stringliteral">&quot;*************Non positive growth factor*************. Value %12.4e\n&quot;</span>, fac[q].val());</div><div class="line">}</div><div class="line">    </div><div class="line"><span class="keywordflow">if</span> (fac[q] &lt; sat){ fac[q] = 1.0; }</div><div class="line"><span class="keywordflow">else</span>{ fac[q] /= sat; }</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span>(std::strcmp(GROWTH.c_str(),<span class="stringliteral">&quot;Isotropic&quot;</span>)==0 ){</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i){</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j){</div><div class="line">            Fe[q][i][j]=defMap.F[q][i][j]/fac[q];</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }       </div></div><!-- fragment --><p> After all this we can evaluate stress. For Neohookean model </p><p class="formulaDsp">
\[ \boldsymbol{P}=\boldsymbol{F}^e\boldsymbol{S}\\ \boldsymbol{S}=0.5\lambda\det(\boldsymbol{C})\boldsymbol{C}^{-1}-(0.5\lambda+\mu)\boldsymbol{C}^{-1}+\mu\boldsymbol{1} \]
</p>
<p> where \(\boldsymbol{C}=\boldsymbol{F}^e(\boldsymbol{F}^e)^{T}\). If young's modulus and Possion ratio are provided, we need to set the Lame parameters first and evaluate the stress </p><div class="fragment"><div class="line"><a class="code" href="class_residual.html#a74a86942f009e483e946ac0a0036bd71">Residual&lt;vectorType,dim&gt;::setLameParametersByYoungsModulusPoissonRatio</a>(youngsModulus, poissonRatio);</div><div class="line"><a class="code" href="class_residual.html#a0f9ff6a237d377803ce368b26ca39652">Residual&lt;vectorType,dim&gt;::evaluateNeoHookeanStress</a>(P, Fe);</div></div><!-- fragment --><p> The weak form of elasticity problem is </p><p class="formulaDsp">
\[ \mathscr{R}_u=\int_{\Omega_{\text{e}}}\nabla \boldsymbol{w}\boldsymbol{T} \text{d}v- \int_{s}\boldsymbol{w} \boldsymbol{f} \cdot \boldsymbol{n} \text{d}s = \boldsymbol{0} \]
</p>
<p> Again we just simply call the corresponding function to evalue the residual function for \(\boldsymbol{u}\). </p><div class="fragment"><div class="line"><a class="code" href="class_residual.html#a432fe02216f182fd241f09775131f854">Residual&lt;vectorType,dim&gt;::residualForMechanics</a>(fe_values, primary_variables_dof[0], R, P);</div></div><!-- fragment --><h2><a class="anchor" id="solve"></a>
Solving nonlinear residual functions</h2>
<p>when we have assembled the system_matrix \(\frac{\partial \boldsymbol{R}}{\partial \boldsymbol{x}} \), and right hand side vector \(-\boldsymbol{R}\), we can solve the Nonlinear residual functions using Newton family method. For dynamics problem we just need to specify the initial and total time, and then call <code>nonlinearSolve</code> </p><div class="fragment"><div class="line"> <span class="keywordflow">for</span> (current_time=initial_time; current_time&lt;=total_time; current_time+=dt){</div><div class="line">   current_increment++;</div><div class="line">   t_solve = clock();</div><div class="line">       <a class="code" href="classsolve_class.html#aa848c866771bf63f69e8ff35d4c947aa">solveClass&lt; dim, matrixType, vectorType &gt;::nonlinearSolve</a>(solution);</div><div class="line">       solution_prev=solution;</div><div class="line">}</div></div><!-- fragment --><p> in the <code>solveClass</code>, it will take the system_matrix and right hand side vector generated by <code>updateLinearSystem</code> we overloaded.<br />
 <br />
 Now let us discuss the parameter managements and how to choose parameters in solvers. </p>
<h2><a class="anchor" id="parameter"></a>
Parameterhandler</h2>
<p>Recall that </p><p class="formulaDsp">
\[ \boldsymbol{j}_1^{diff}=-M_1\nabla C_\text{1}; \quad \boldsymbol{j}_2^{diff}=-M_2\nabla C_\text{2}\\ \]
</p>
 <p class="formulaDsp">
\[ r_1= reac_{10} \\ r_1= reac_{20} \]
</p>
<p> In this example (and almost all real applications), there are many parameters. DealShell code use <code>Parameterhandler</code> to manager all parameters, and <code>Parameterhandler</code> is also used in this example to manager the parameters. <code>Parameterhandler</code> allows us to modify parameters at runtime without re-compiling the code. To use <code>Parameterhandler</code> we first need to declare all parameters we will use. Please note parameters used in dealShell are already declared so we only need to declare parameters as we need. In this example we nee </p><div class="fragment"><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;dt&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;totalTime&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line"></div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;mesh&quot;</span>,<span class="stringliteral">&quot;1&quot;</span>,Patterns::FileName() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;output_directory&quot;</span>,<span class="stringliteral">&quot;1&quot;</span>,Patterns::DirectoryName() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;snapshot_directory&quot;</span>,<span class="stringliteral">&quot;1&quot;</span>,Patterns::DirectoryName() );</div><div class="line"></div><div class="line"><span class="comment">//declare paramters for mechanics</span></div><div class="line">params-&gt;enter_subsection(<span class="stringliteral">&quot;Mechanics&quot;</span>);</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;youngsModulus&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;poissonRatio&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;saturation_matID_0&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;saturation_matID_1&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line"></div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;GROWTH&quot;</span>,<span class="stringliteral">&quot;Isotropic&quot;</span>,Patterns::Selection(<span class="stringliteral">&quot;Uniform|Isotropic&quot;</span>) );</div><div class="line">params-&gt;leave_subsection(); </div><div class="line"></div><div class="line"><span class="comment">//declare paramters for concentrations</span></div><div class="line">params-&gt;enter_subsection(<span class="stringliteral">&quot;Concentration&quot;</span>);</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;c1_ini&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;c2_ini&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;c1_ini_interface&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;c2_ini_interface&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line"></div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;mobility_c1&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;mobility_c2&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;reac_10&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line">params-&gt;declare_entry(<span class="stringliteral">&quot;reac_20&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,Patterns::Double() );</div><div class="line">params-&gt;leave_subsection(); </div></div><!-- fragment --><p> Then we need to create a <code></code>.prm file to set values for all parameters. Also we need to set parameters for solvers in the file. </p><div class="fragment"><div class="line"><span class="preprocessor">#parameters file</span></div><div class="line"></div><div class="line"><span class="preprocessor">#set global parameters</span></div><div class="line">set dt = 0.1</div><div class="line">set totalTime = 1</div><div class="line"></div><div class="line">set mesh = /Users/wzhenlin/GitLab/researchCode/brainMorph/mesh/testMesh.msh</div><div class="line">set output_directory = output/</div><div class="line">set snapshot_directory = snapshot/</div><div class="line"><span class="preprocessor"># set equations &lt;name /&gt;type(not useful now)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#set Mechanics = NeoHookean finite strain</span></div><div class="line"><span class="preprocessor">#set Concentration = Diffusion reaction</span></div><div class="line"></div><div class="line"></div><div class="line">subsection Mechanics</div><div class="line">        set youngsModulus =  5.0e3</div><div class="line">        set poissonRatio =  0.45</div><div class="line">            </div><div class="line">        set saturation_matID_0 = 10</div><div class="line">        set saturation_matID_1 = 1</div><div class="line">        </div><div class="line">     set GROWTH = Tangential</div><div class="line"><span class="preprocessor">        #set GROWTH = Isotropic</span></div><div class="line">end</div><div class="line"></div><div class="line">subsection Concentration</div><div class="line">        set c1_ini = 0.5</div><div class="line">        set c2_ini = 0.5</div><div class="line">        set c1_ini_interface = 1</div><div class="line">        set c2_ini_interface = 1</div><div class="line">                        </div><div class="line">        set mobility_c1 = 0.1</div><div class="line">     set mobility_c2 = 0.1</div><div class="line">     set reac_10 = 0</div><div class="line">        set reac_20 = 0</div><div class="line"></div><div class="line">end</div><div class="line">                        </div><div class="line"><span class="preprocessor">#</span></div><div class="line"><span class="preprocessor"># parameters reserved for deal.ii first level code:</span></div><div class="line"><span class="preprocessor">#nonLinear_method : classicNewton</span></div><div class="line"><span class="preprocessor">#solver_method (direct) : PETScsuperLU, PETScMUMPS</span></div><div class="line"><span class="preprocessor">#solver_method (iterative) : PETScGMRES PETScBoomerAMG</span></div><div class="line"><span class="preprocessor">#relative_norm_tolerance, absolute_norm_tolerance, max_iterations</span></div><div class="line"><span class="preprocessor">#</span></div><div class="line">subsection Nonlinear_solver</div><div class="line">        set nonLinear_method = classicNewton</div><div class="line">        set relative_norm_tolerance = 5.0e-12</div><div class="line">        set absolute_norm_tolerance = 5.0e-12</div><div class="line">        set max_iterations = 50</div><div class="line">end</div><div class="line">                        </div><div class="line">subsection Linear_solver</div><div class="line">        set solver_method = PETScMUMPS</div><div class="line">        set system_matrix_symmetricFlag = <span class="keyword">false</span> # <span class="keywordflow">default</span> is <span class="keyword">false</span></div><div class="line">end</div></div><!-- fragment --><p> Alteravely we can use GUI to set the parameters. </p>
<h1><a class="anchor" id="lib"></a>
mechanoChemFEM lib</h1>
<p>To use mechanoChemFEM lib, we need to define a class derived from <code>solveClass&lt;int dim, class matrixType, class vectorType&gt;</code> and <code>hpFEM&lt;int dim&gt;</code>, so that we can used pre-defined variables, functions, and overload the abstract virtual function <code>updateLinearSystem()</code> in parent class. The last reason make the inherientance necessary. Also we usually include the following three classes </p><div class="fragment"><div class="line">ParameterHandler* params;   </div><div class="line"><a class="code" href="class_residual.html">Residual&lt;Sacado::Fad::DFad&lt;double&gt;</a>,dim&gt;* ResidualEq;</div><div class="line"><a class="code" href="class_f_e_mdata.html">FEMdata&lt;dim, PETScWrappers::MPI::Vector&gt;</a>* FEMdata_out;</div></div><!-- fragment --> <h1><a class="anchor" id="results"></a>
Results</h1>
<p> <style>div.image img[src="c1.png"]{width:500px;}</style>  </p><div class="image">
<img src="c1.png" alt="c1.png"/>
<div class="caption">
concentraion c1 at deformed configuration</div></div>
<p>  <style>div.image img[src="u.png"]{width:500px;}</style>  </p><div class="image">
<img src="u.png" alt="u.png"/>
<div class="caption">
displacment magnitude</div></div>
 <h1><a class="anchor" id="com"></a>
Complete code</h1>
<p>The complete implementaion can be found at <a href="https://github.com/mechanoChem/mechanoChemFEM/tree/example/brainMorph">Github</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
